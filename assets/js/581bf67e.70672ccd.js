"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[713],{5680(e,n,t){t.d(n,{xA:()=>p,yg:()=>h});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach(function(n){i(e,n,t[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})}return e}function l(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),g=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},p=function(e){var n=g(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef(function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=g(t),h=i,d=m["".concat(s,".").concat(h)]||m[h]||c[h]||o;return t?a.createElement(d,r(r({ref:n},p),{},{components:t})):a.createElement(d,r({ref:n},p))});function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var g=2;g<o;g++)r[g]=t[g];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},9891(e,n,t){t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>g});var a=t(8168),i=(t(6540),t(5680));const o={id:"week10",title:"Week 10: Task & Motion Planning",slug:"/isaac-sim/week10",sidebar_label:"Week 10: Task & Motion Planning",estimated_time:5,week:10,module:"The AI-Robot Brain (NVIDIA Isaac\u2122)",prerequisites:["week9"],learning_objectives:["Understand the difference between task planning and motion planning.","Use a motion planner to generate collision-free paths.","Implement a simple task planner to sequence actions.","Integrate motion planning with a behavior tree."]},r="Week 10: Task & Motion Planning",l={unversionedId:"isaac-sim/week10",id:"isaac-sim/week10",title:"Week 10: Task & Motion Planning",description:"This week, we will give our robot the ability to reason about and plan its actions. We will explore the concepts of task planning and motion planning, and how they work together to enable intelligent behavior.",source:"@site/docs/isaac-sim/week10.md",sourceDirName:"isaac-sim",slug:"/isaac-sim/week10",permalink:"/humanoid-robotics-book/docs/isaac-sim/week10",draft:!1,tags:[],version:"current",frontMatter:{id:"week10",title:"Week 10: Task & Motion Planning",slug:"/isaac-sim/week10",sidebar_label:"Week 10: Task & Motion Planning",estimated_time:5,week:10,module:"The AI-Robot Brain (NVIDIA Isaac\u2122)",prerequisites:["week9"],learning_objectives:["Understand the difference between task planning and motion planning.","Use a motion planner to generate collision-free paths.","Implement a simple task planner to sequence actions.","Integrate motion planning with a behavior tree."]},sidebar:"tutorialSidebar",previous:{title:"Week 9: Perception",permalink:"/humanoid-robotics-book/docs/isaac-sim/week9"},next:{title:"Module 4: VLA",permalink:"/humanoid-robotics-book/docs/vla-module"}},s={},g=[{value:"Topics Covered",id:"topics-covered",level:2},{value:"The Planning Hierarchy",id:"the-planning-hierarchy",level:2},{value:"Collision-Free Motion Planning",id:"collision-free-motion-planning",level:2},{value:"Popular Motion Planning Algorithms",id:"popular-motion-planning-algorithms",level:3},{value:"Task Planning with State Machines and Behavior Trees",id:"task-planning-with-state-machines-and-behavior-trees",level:2},{value:"State Machines",id:"state-machines",level:3},{value:"Behavior Trees",id:"behavior-trees",level:3},{value:"Integrating Planning with Execution",id:"integrating-planning-with-execution",level:2}],p={toc:g};function c({components:e,...n}){return(0,i.yg)("wrapper",(0,a.A)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"week-10-task--motion-planning"},"Week 10: Task & Motion Planning"),(0,i.yg)("p",null,"This week, we will give our robot the ability to reason about and plan its actions. We will explore the concepts of task planning and motion planning, and how they work together to enable intelligent behavior."),(0,i.yg)("h2",{id:"topics-covered"},"Topics Covered"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"The Planning Hierarchy:")," From high-level goals to low-level motor commands."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Collision-Free Motion Planning:")," A* and RRT algorithms."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Task Planning with State Machines and Behavior Trees:")," Two common approaches."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Integrating Planning with Execution:")," How to make your robot ",(0,i.yg)("em",{parentName:"li"},"do")," what it ",(0,i.yg)("em",{parentName:"li"},"thinks"),".")),(0,i.yg)("p",null,"This week, we will give our robot the ability to reason about and plan its actions. We will explore the concepts of task planning and motion planning, and how they work together to enable intelligent behavior."),(0,i.yg)("h2",{id:"the-planning-hierarchy"},"The Planning Hierarchy"),(0,i.yg)("p",null,"Robot intelligence is often structured in a ",(0,i.yg)("strong",{parentName:"p"},"planning hierarchy"),", where different levels of abstraction handle increasingly detailed aspects of behavior:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Task Planning (High-Level):")," Decides ",(0,i.yg)("em",{parentName:"li"},"what"),' the robot should do. This involves symbolic reasoning about goals, preconditions, and effects of actions. For example, "go to the kitchen and make coffee."'),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Motion Planning (Mid-Level):")," Decides ",(0,i.yg)("em",{parentName:"li"},"how"),' the robot should execute a task, generating a collision-free path for the robot\'s end-effector or base. For example, "move the gripper from current position to position X, avoiding obstacle Y."'),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Trajectory Generation (Low-Level):")," Converts the planned path into smooth, time-parametrized joint commands that respect the robot's physical limits (velocity, acceleration)."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Control (Lowest-Level):")," Executes the trajectory by sending commands to the robot's joint motors (e.g., using PID controllers as discussed in Week 8).")),(0,i.yg)("p",null,"This hierarchical approach breaks down complex problems into manageable sub-problems, making it easier to design and debug robot behaviors."),(0,i.yg)("h2",{id:"collision-free-motion-planning"},"Collision-Free Motion Planning"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Motion planning")," is the process of finding a sequence of valid configurations that moves a robot from a start configuration to a goal configuration while avoiding collisions with obstacles and respecting joint limits. For humanoid robots, motion planning is particularly challenging due to their high dimensionality and the need to maintain balance."),(0,i.yg)("h3",{id:"popular-motion-planning-algorithms"},"Popular Motion Planning Algorithms"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"A* (A-star) Algorithm:")," A popular pathfinding algorithm that finds the shortest path between two points in a grid-based map. It is guaranteed to find the optimal path if one exists but can be computationally expensive in high-dimensional spaces."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"RRT (Rapidly-exploring Random Tree) and RRT* Algorithms:")," These are sampling-based algorithms well-suited for high-dimensional spaces. They build a tree of possible paths by randomly sampling configurations and connecting them to the nearest existing node in the tree.",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"RRT:")," Explores the configuration space efficiently but does not guarantee optimality."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"RRT*:")," An extension of RRT that aims for asymptotic optimality, meaning it converges to an optimal path as the number of samples approaches infinity."))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"PRM (Probabilistic RoadMap) Algorithm:")," Another sampling-based method that constructs a roadmap in the configuration space during a preprocessing phase. This roadmap can then be used to query paths efficiently between different start and goal configurations.")),(0,i.yg)("p",null,"These algorithms are often implemented in libraries like OMPL (Open Motion Planning Library) and integrated into robotic frameworks like MoveIt for ROS 2."),(0,i.yg)("h2",{id:"task-planning-with-state-machines-and-behavior-trees"},"Task Planning with State Machines and Behavior Trees"),(0,i.yg)("p",null,"While motion planning deals with ",(0,i.yg)("em",{parentName:"p"},"how")," to move, ",(0,i.yg)("strong",{parentName:"p"},"task planning")," addresses ",(0,i.yg)("em",{parentName:"p"},"what")," actions to take and in what order. Two popular approaches for task planning in robotics are state machines and behavior trees."),(0,i.yg)("h3",{id:"state-machines"},"State Machines"),(0,i.yg)("p",null,'As discussed in Week 8, state machines are excellent for modeling sequential processes with distinct states and transitions. In task planning, each state could represent a major step in a task (e.g., "go to table", "pick up object", "place object"). Transitions occur based on the successful completion of a sub-task or an external event.'),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Pros:")," Easy to understand for simple, sequential tasks; clear definition of states and transitions."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Cons:")," Can become complex and hard to manage for highly reactive or parallel behaviors.")),(0,i.yg)("h3",{id:"behavior-trees"},"Behavior Trees"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Behavior Trees")," (BTs) offer a more modular and flexible way to represent complex robot behaviors, especially those requiring reactive and hierarchical control. A behavior tree is a directed acyclic graph where nodes are either ",(0,i.yg)("strong",{parentName:"p"},"control flow nodes")," (composites) or ",(0,i.yg)("strong",{parentName:"p"},"execution nodes")," (leaves)."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Control Flow Nodes:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Sequences (",(0,i.yg)("inlineCode",{parentName:"strong"},"->"),"):")," Execute children from left to right until one fails; if all succeed, the sequence succeeds."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Fallbacks (",(0,i.yg)("inlineCode",{parentName:"strong"},"?"),"):")," Execute children from left to right until one succeeds; if all fail, the fallback fails."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Parallels (",(0,i.yg)("inlineCode",{parentName:"strong"},"=>"),"):")," Execute multiple children concurrently."))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Execution Nodes:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Conditions:")," Check if a certain condition is met."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("strong",{parentName:"li"},"Actions:")," Perform a specific action (e.g., call a motion planner, open a gripper).")))),(0,i.yg)("p",null,"Behavior trees allow for highly modular, readable, and reusable behavior logic. They naturally handle preemption and reactivity, making them very popular in modern robotics and game AI."),(0,i.yg)("h2",{id:"integrating-planning-with-execution"},"Integrating Planning with Execution"),(0,i.yg)("p",null,"The real challenge lies in integrating these planning layers (task and motion) with the robot's actual execution."),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Task Planner Output:"),' A task planner (e.g., a behavior tree) might output a high-level sequence of actions like "Approach object", "Grasp object", "Lift object".'),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Motion Planner Input:"),' Each of these high-level actions needs to be translated into inputs for the motion planner. For "Approach object," the motion planner would receive a target pose for the robot\'s end-effector relative to the object.'),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Controller Input:")," The motion planner then generates a trajectory (a series of joint positions, velocities, and accelerations over time), which is fed to the low-level joint controllers (e.g., ",(0,i.yg)("inlineCode",{parentName:"li"},"ros2_control")," with PID loops) for execution."),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("strong",{parentName:"li"},"Feedback and Replanning:")," The execution system provides feedback (e.g., current joint positions, sensor readings, success/failure of an action) to both the motion planner (for dynamic obstacle avoidance or replanning) and the task planner (to decide the next action or handle failures).")),(0,i.yg)("p",null,"This iterative loop of planning, execution, and feedback allows the robot to achieve its goals robustly in dynamic and uncertain environments."))}c.isMDXComponent=!0}}]);