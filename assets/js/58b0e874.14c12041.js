"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[404],{1494(e,t,o){o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=o(8168),r=(o(6540),o(5680));const a={id:"ros2-control",title:"Module 2: Using ros2_control",sidebar_label:"ros2_control"},i=void 0,l={unversionedId:"digital-twin/ros2-control",id:"digital-twin/ros2-control",title:"Module 2: Using ros2_control",description:"Real-time Control with ros2_control",source:"@site/docs/digital-twin/ros2-control.md",sourceDirName:"digital-twin",slug:"/digital-twin/ros2-control",permalink:"/humanoid-robotics-book/docs/digital-twin/ros2-control",draft:!1,tags:[],version:"current",frontMatter:{id:"ros2-control",title:"Module 2: Using ros2_control",sidebar_label:"ros2_control"},sidebar:"tutorialSidebar",previous:{title:"Week 7: Building a Digital Twin",permalink:"/humanoid-robotics-book/docs/digital-twin/week7"},next:{title:"Module 3: NVIDIA Isaac",permalink:"/humanoid-robotics-book/docs/isaac-module"}},s={},c=[{value:"Real-time Control with <code>ros2_control</code>",id:"real-time-control-with-ros2_control",level:2},{value:"Why use <code>ros2_control</code>?",id:"why-use-ros2_control",level:3},{value:"The <code>ros2_control</code> Architecture",id:"the-ros2_control-architecture",level:3},{value:"<code>ros2_control</code> with Isaac Sim",id:"ros2_control-with-isaac-sim",level:3},{value:"Sending a Goal to a Controller",id:"sending-a-goal-to-a-controller",level:3}],p={toc:c};function d({components:e,...t}){return(0,r.yg)("wrapper",(0,n.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("h2",{id:"real-time-control-with-ros2_control"},"Real-time Control with ",(0,r.yg)("inlineCode",{parentName:"h2"},"ros2_control")),(0,r.yg)("p",null,"While publishing joint commands directly to Isaac Sim works for simple cases, a more robust and standard approach for robot control in ROS 2 is using the ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," framework. ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," is a set of packages that provides a standardized way to interface with robot hardware. By using it with our digital twin, we create a seamless transition from simulation to a physical robot."),(0,r.yg)("h3",{id:"why-use-ros2_control"},"Why use ",(0,r.yg)("inlineCode",{parentName:"h3"},"ros2_control"),"?"),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," framework provides several key advantages:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Standardization:")," It provides a common interface for controllers (like joint trajectory controllers) and hardware (or simulation) backends."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Real-time Safety:")," It is designed with real-time performance and safety in mind, which is critical for physical robots."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Controller Management:")," It includes a controller manager that can load, unload, start, and stop different controllers at runtime without restarting the robot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Abstraction:")," Your high-level code (e.g., a navigation stack) doesn't need to know the details of how the robot's joints are controlled. It just sends a standard goal (like a trajectory) to a ",(0,r.yg)("inlineCode",{parentName:"li"},"ros2_control")," controller.")),(0,r.yg)("h3",{id:"the-ros2_control-architecture"},"The ",(0,r.yg)("inlineCode",{parentName:"h3"},"ros2_control")," Architecture"),(0,r.yg)("p",null,"The main components of ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," are:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Hardware Interface:")," This is the component that communicates directly with the robot's hardware (or, in our case, the simulator). It reads sensor data (like joint positions) and writes commands (like joint velocities). For Isaac Sim, there are specialized hardware interface plugins."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Controller Manager:")," A node that manages the lifecycle of controllers."),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("strong",{parentName:"li"},"Controllers:")," These are the algorithms that compute the commands to be sent to the hardware. Common controllers include:",(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"joint_state_broadcaster"),": Reads the current state of the joints from the hardware interface and publishes them as ",(0,r.yg)("inlineCode",{parentName:"li"},"sensor_msgs/msg/JointState"),"."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"joint_trajectory_controller"),": Accepts a trajectory of joint positions and executes it on the robot."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"diff_drive_controller"),": For controlling differential drive mobile robots.")))),(0,r.yg)("h3",{id:"ros2_control-with-isaac-sim"},(0,r.yg)("inlineCode",{parentName:"h3"},"ros2_control")," with Isaac Sim"),(0,r.yg)("p",null,"NVIDIA provides a ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," hardware interface for Isaac Sim. This allows ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," to treat the simulated robot in Isaac Sim as its hardware backend."),(0,r.yg)("p",null,"Here is the typical workflow:"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"URDF Configuration:")," Your robot's URDF is updated to include special ",(0,r.yg)("inlineCode",{parentName:"p"},"<ros2_control>")," tags. These tags define the available command interfaces (e.g., ",(0,r.yg)("inlineCode",{parentName:"p"},"position"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"velocity"),") and state interfaces for each joint."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-xml"},'<ros2_control name="IsaacSimSystem" type="system">\n  <hardware>\n    <plugin>isaac_sim_ros2_control/IsaacSimROS2ControlHardware</plugin>\n    <param name="robot_description_topic">/robot_description</param>\n  </hardware>\n  <joint name="shoulder_joint">\n    <command_interface name="position"/>\n    <state_interface name="position"/>\n    <state_interface name="velocity"/>\n  </joint>\n</ros2_control>\n'))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Controller Configuration:")," You create a YAML file to configure the controllers you want to use."),(0,r.yg)("pre",{parentName:"li"},(0,r.yg)("code",{parentName:"pre",className:"language-yaml"},"controller_manager:\n  ros__parameters:\n    update_rate: 100\n    use_sim_time: true\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    joint_trajectory_controller:\n      type: joint_trajectory_controller/JointTrajectoryController\n\njoint_trajectory_controller:\n  ros__parameters:\n    joints:\n      - shoulder_joint\n    command_interfaces:\n      - position\n    state_interfaces:\n      - position\n      - velocity\n"))),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Launch:")," A launch file is used to:"),(0,r.yg)("ul",{parentName:"li"},(0,r.yg)("li",{parentName:"ul"},"Load the robot description (URDF)."),(0,r.yg)("li",{parentName:"ul"},"Start the ",(0,r.yg)("inlineCode",{parentName:"li"},"ros2_control")," controller manager (",(0,r.yg)("inlineCode",{parentName:"li"},"ros2_control_node"),")."),(0,r.yg)("li",{parentName:"ul"},"Load and start the controllers defined in the YAML file.")))),(0,r.yg)("h3",{id:"sending-a-goal-to-a-controller"},"Sending a Goal to a Controller"),(0,r.yg)("p",null,"With ",(0,r.yg)("inlineCode",{parentName:"p"},"ros2_control")," set up, you no longer publish low-level joint commands. Instead, you send a high-level goal to the appropriate controller. For the ",(0,r.yg)("inlineCode",{parentName:"p"},"joint_trajectory_controller"),', this is an "action" of type ',(0,r.yg)("inlineCode",{parentName:"p"},"control_msgs/action/FollowJointTrajectory"),"."),(0,r.yg)("p",null,"Here is a simplified Python example of sending a trajectory goal to move the ",(0,r.yg)("inlineCode",{parentName:"p"},"shoulder_joint"),"."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},"# trajectory_goal_sender.py\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom control_msgs.action import FollowJointTrajectory\nfrom trajectory_msgs.msg import JointTrajectoryPoint\n\nclass TrajectoryClient(Node):\n    def __init__(self):\n        super().__init__('trajectory_client')\n        self._action_client = ActionClient(self, FollowJointTrajectory, '/joint_trajectory_controller/follow_joint_trajectory')\n\n    def send_goal(self):\n        goal_msg = FollowJointTrajectory.Goal()\n        goal_msg.trajectory.joint_names = ['shoulder_joint']\n        \n        point = JointTrajectoryPoint()\n        point.positions = [0.5] # Target position in radians\n        point.time_from_start.sec = 2\n        goal_msg.trajectory.points.append(point)\n\n        self.get_logger().info('Sending goal...')\n        self._action_client.wait_for_server()\n        self._send_goal_future = self._action_client.send_goal_async(goal_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    action_client = TrajectoryClient()\n    action_client.send_goal()\n    rclpy.spin(action_client) # Keep node alive to handle action feedback/result\n    action_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n")),(0,r.yg)("p",null,"This approach is much more powerful. You can specify a sequence of points with velocities and accelerations, and the controller will handle the smooth execution of the trajectory. This is how complex arm movements are orchestrated in ROS 2."))}d.isMDXComponent=!0},5680(e,t,o){o.d(t,{xA:()=>p,yg:()=>g});var n=o(6540);function r(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),o.push.apply(o,n)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach(function(t){r(e,t,o[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))})}return e}function l(e,t){if(null==e)return{};var o,n,r=function(e,t){if(null==e)return{};var o,n,r={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(r[o]=e[o]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=n.createContext({}),c=function(e){var t=n.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef(function(e,t){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(o),g=r,y=m["".concat(s,".").concat(g)]||m[g]||d[g]||a;return o?n.createElement(y,i(i({ref:t},p),{},{components:o})):n.createElement(y,i({ref:t},p))});function g(e,t){var o=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=o[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,o)}m.displayName="MDXCreateElement"}}]);