"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[300],{5680(e,n,r){r.d(n,{xA:()=>d,yg:()=>f});var t=r(6540);function i(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter(function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable})),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach(function(n){i(e,n,r[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach(function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))})}return e}function a(e,n){if(null==e)return{};var r,t,i=function(e,n){if(null==e)return{};var r,t,i={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(i[r]=e[r]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=t.createContext({}),c=function(e){var n=t.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):s(s({},n),e)),r},d=function(e){var n=c(e.components);return t.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef(function(e,n){var r=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=a(e,["components","mdxType","originalType","parentName"]),p=c(r),f=i,m=p["".concat(l,".").concat(f)]||p[f]||u[f]||o;return r?t.createElement(m,s(s({ref:n},d),{},{components:r})):t.createElement(m,s({ref:n},d))});function f(e,n){var r=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=r.length,s=new Array(o);s[0]=p;var a={};for(var l in n)hasOwnProperty.call(n,l)&&(a[l]=n[l]);a.originalType=e,a.mdxType="string"==typeof e?e:i,s[1]=a;for(var c=2;c<o;c++)s[c]=r[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},7578(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var t=r(8168),i=(r(6540),r(5680));const o={id:"week5",title:"Module 1: ROS 2 Services & Actions",sidebar_label:"Week 5: Services & Actions"},s=void 0,a={unversionedId:"ros2/week5",id:"ros2/week5",title:"Module 1: ROS 2 Services & Actions",description:"Week 5: ROS 2 Services and Actions",source:"@site/docs/ros2/week5.md",sourceDirName:"ros2",slug:"/ros2/week5",permalink:"/humanoid-robotics-book/docs/ros2/week5",draft:!1,tags:[],version:"current",frontMatter:{id:"week5",title:"Module 1: ROS 2 Services & Actions",sidebar_label:"Week 5: Services & Actions"},sidebar:"tutorialSidebar",previous:{title:"Week 4: Core Concepts",permalink:"/humanoid-robotics-book/docs/ros2/week4"},next:{title:"tf2",permalink:"/humanoid-robotics-book/docs/ros2/tf2"}},l={},c=[{value:"Week 5: ROS 2 Services and Actions",id:"week-5-ros-2-services-and-actions",level:2},{value:"ROS 2 Services",id:"ros-2-services",level:3},{value:"Service Definition (<code>.srv</code> file)",id:"service-definition-srv-file",level:4},{value:"Service Server Node",id:"service-server-node",level:4},{value:"Service Client Node",id:"service-client-node",level:4},{value:"ROS 2 Actions",id:"ros-2-actions",level:3}],d={toc:c};function u({components:e,...n}){return(0,i.yg)("wrapper",(0,t.A)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,i.yg)("h2",{id:"week-5-ros-2-services-and-actions"},"Week 5: ROS 2 Services and Actions"),(0,i.yg)("p",null,"This week, we expand on our ROS 2 knowledge by exploring two additional communication patterns: Services and Actions. These are essential for request/response and long-running tasks in robotics."),(0,i.yg)("h3",{id:"ros-2-services"},"ROS 2 Services"),(0,i.yg)("p",null,'Services are used for synchronous request/response communication. A "service client" sends a request to a "service server," which processes the request and sends back a response. This is useful for tasks that should be completed quickly and will always result in a response. For example, a service could be used to query the current position of a robot\'s arm.'),(0,i.yg)("p",null,"Let's create a simple service that adds two integers."),(0,i.yg)("h4",{id:"service-definition-srv-file"},"Service Definition (",(0,i.yg)("inlineCode",{parentName:"h4"},".srv")," file)"),(0,i.yg)("p",null,"First, we need to define the service interface in a ",(0,i.yg)("inlineCode",{parentName:"p"},".srv")," file. Let's call it ",(0,i.yg)("inlineCode",{parentName:"p"},"AddTwoInts.srv"),"."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"int64 a\nint64 b\n---\nint64 sum\n")),(0,i.yg)("p",null,"The part above the ",(0,i.yg)("inlineCode",{parentName:"p"},"---")," is the request, and the part below is the response."),(0,i.yg)("h4",{id:"service-server-node"},"Service Server Node"),(0,i.yg)("p",null,"Here is the Python code for the service server."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"# add_two_ints_server.py\nfrom example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalService(Node):\n    def __init__(self):\n        super().__init__('minimal_service')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request\\na: {request.a} b: {request.b}')\n        self.get_logger().info(f'Sending back response: [{response.sum}]')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_service = MinimalService()\n    rclpy.spin(minimal_service)\n    minimal_service.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n")),(0,i.yg)("h4",{id:"service-client-node"},"Service Client Node"),(0,i.yg)("p",null,"Here is the Python code for the service client that calls the server."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-python"},"# add_two_ints_client.py\nfrom example_interfaces.srv import AddTwoInts\nimport rclpy\nfrom rclpy.node import Node\n\nclass MinimalClientAsync(Node):\n    def __init__(self):\n        super().__init__('minimal_client_async')\n        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('service not available, waiting again...')\n        self.req = AddTwoInts.Request()\n\n    def send_request(self, a, b):\n        self.req.a = a\n        self.req.b = b\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    minimal_client = MinimalClientAsync()\n    response = minimal_client.send_request(5, 10)\n    minimal_client.get_logger().info(\n        f'Result of add_two_ints: for 5 + 10 = {response.sum}')\n    minimal_client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n")),(0,i.yg)("h3",{id:"ros-2-actions"},"ROS 2 Actions"),(0,i.yg)("p",null,"Actions are used for long-running tasks that provide feedback during execution. Think of navigating a robot to a goal position. This task might take a while, and you'd want to receive updates on its progress. Actions consist of a goal, feedback, and a result."),(0,i.yg)("p",null,'An "action client" sends a goal to an "action server". The server executes the goal, provides periodic feedback to the client, and sends a final result when the task is complete. This is an asynchronous process.'),(0,i.yg)("p",null,"Due to the complexity of a full action example, we will revisit a practical implementation in a later module when we work with navigation. The core concept to remember is that actions are for tasks that take time and where you need to know what's happening during execution."))}u.isMDXComponent=!0}}]);